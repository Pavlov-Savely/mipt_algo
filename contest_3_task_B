#include <algorithm>
#include <iostream>
#include <map>
#include <set>
#include <vector>

const int64_t INF = 1e18;

class Graph {
public:
    explicit Graph(int n) : adjacency_list_(n) {}

    void addEdge(int u, int v, int64_t time) {
        adjacency_list_[u].push_back({v, time});
        adjacency_list_[v].push_back({u, time});
    }

    const std::vector<std::pair<int64_t, int64_t>>& getNeighbors(int v) const {
        return adjacency_list_[v];
    }

    int size() const {
        return adjacency_list_.size();
    }

private:
    std::vector<std::vector<std::pair<int64_t, int64_t>>> adjacency_list_;
};

void input(
    int64_t n, int64_t m, int64_t k, int64_t& start, int64_t& finish,
    std::vector<int64_t>& viruses,
    Graph& graph) {
  for (int64_t i = 0; i < k; i++) {
    int64_t virus;
    std::cin >> virus;
    viruses.push_back(virus - 1);
  }

  int64_t u, v, time;
  for (int64_t i = 0; i < m; i++) {
    std::cin >> u >> v >> time;
    graph.addEdge(u - 1, v - 1, time);
  }
  std::cin >> start >> finish;
  start--;
  finish--;
}

void dijkstra_viruses(const Graph& graph, std::vector<int64_t>& dist, const std::vector<int64_t>& viruses) {
  std::set<std::pair<int64_t, int64_t>> heap;
  for (int64_t virus : viruses) {
    heap.insert({0, virus});
    dist[virus] = 0;
  }

  while (!heap.empty()) {
    auto best_edge = *heap.begin();
    auto best_vertex = best_edge.second;
    auto best_weight = best_edge.first;
    heap.erase(heap.begin());

    for (auto& [neighbour, time] : graph.getNeighbors(best_vertex)) {
      if (dist[neighbour] > (int64_t)time + best_weight) {
        heap.erase({dist[neighbour], neighbour});
        dist[neighbour] = time + best_weight;
        heap.insert({dist[neighbour], neighbour});
      }
    }
  }
}

void dijkstra_mission(int64_t s, const Graph& graph, std::vector<int64_t>& dist, const std::vector<int64_t>& dist_viruses) {
  std::set<std::pair<int64_t, int64_t>> heap;
  heap.insert({0, s});
  dist[s] = 0;

  while (!heap.empty()) {
    auto best_edge = *heap.begin();
    auto best_vertex = best_edge.second;
    auto best_weight = best_edge.first;
    heap.erase(heap.begin());

    for (auto& [neighbour, time] : graph.getNeighbors(best_vertex)) {
      if (dist_viruses[neighbour] > time + best_weight && dist[neighbour] > time + best_weight) {
        heap.erase({dist[neighbour], neighbour});
        dist[neighbour] = time + best_weight;
        heap.insert({dist[neighbour], neighbour});
      }
    }
  }
}

int64_t calc_min_time(
    int64_t n, int64_t m, int64_t k, int64_t start, int64_t finish,
    const std::vector<int64_t>& viruses,
    const Graph& graph) {
  std::vector<int64_t> dist_viruses(n, INF);
  dijkstra_viruses(graph, dist_viruses, viruses);

  std::vector<int64_t> dist_mission(n, INF);
  dijkstra_mission(start, graph, dist_mission, dist_viruses);

  if (dist_mission[finish] == INF) {
    return -1;
  }

  return dist_mission[finish];
}

int main() {
  int64_t n, m, k;
  std::cin >> n >> m >> k;

  int64_t start, finish;
  std::vector<int64_t> viruses;
  Graph graph(n);

  input(n, m, k, start, finish, viruses, graph);

  int64_t ans = calc_min_time(n, m, k, start, finish, viruses, graph);

  std::cout << ans << '\n';
}
